#ifdef USE_GTK
#include <gtk/gtk.h>
#else
typedef unsigned char guchar;
#endif

#include "stdinclude.h"
#include "Vector3.h"
#include "Ray3.h"
#include "Intersect.h"
#include "Geometry.h"
#include "Camera.h"
#include "Light.h"

struct pixels_info {
#ifdef USE_GTK
	GdkPixbuf *const pixbuf;
#endif

	const int width;
	const int height;
	const int nchannels;
	const int rowstride;
	guchar *pixels;

#ifdef USE_GTK
	pixels_info(GdkPixbuf *pixbuf) : pixbuf(pixbuf),
		width(gdk_pixbuf_get_width(pixbuf)),
		height(gdk_pixbuf_get_height(pixbuf)),
		nchannels(gdk_pixbuf_get_n_channels(pixbuf)),
		rowstride(gdk_pixbuf_get_rowstride(pixbuf)),
		pixels(gdk_pixbuf_get_pixels(pixbuf)) {}
#else
	pixels_info(int width, int height) :
		width(width), height(height), nchannels(3), rowstride(nchannels * width),
		pixels(new guchar[rowstride * height]) {}

	~pixels_info() { delete [] pixels; }
#endif

	void save_ppm(ofstream &fout)
	{
		fout << "P6" << "# PPM Image Generated by "
			     << "My Console 3D Render Program, "
			     << "(Powered by archibate@github.com)"
			     << endl;
		fout << this->width << " " << this->height << endl;
		fout << "255" << endl;

		fout.write((const char *) pixels, this->height * this->rowstride);
	}

	guchar *get_ptr(int x, int y) const { return this->pixels
		+ y * this->rowstride + x * this->nchannels; }
};

void renderLight(const pixels_info &info, const Geometry &scene, const Light &light)
{
	Camera camera;

	int w(info.width), h(info.height);

#pragma omp parallel for schedule(dynamic, 1)
	for (int y = 0; y < h; y++) {
		real sy(y*2.0/h-1);

		for (int x = 0; x < w; x++) {
			real sx(1-x*2.0/w);

			//cout << "(" << sx << ", " << sy << ")" << endl;

			Ray3 ray(camera.generateRay(sx, sy));
			Intersect result(scene.intersect(ray));
			Color3 color(light.colorize(scene, result.position, result.normal));

			guchar *p = info.get_ptr(x, y);
			p[0] = MAX(0, MIN(1, color.r)) * 255;
			p[1] = MAX(0, MIN(1, color.g)) * 255;
			p[2] = MAX(0, MIN(1, color.b)) * 255;
		}
	}
}

void render(const pixels_info &info, const Geometry &scene, const Light &light)
{
	Camera camera;

	int w(info.width), h(info.height);

#pragma omp parallel for schedule(dynamic, 1)
	for (int y = 0; y < h; y++) {
		real sy(y*2.0/h-1);

		for (int x = 0; x < w; x++) {
			real sx(1-x*2.0/w);

			//cout << "(" << sx << ", " << sy << ")" << endl;

			Ray3 ray(camera.generateRay(sx, sy));
			Color3 color(ray.trace(scene, light));

			guchar *p = info.get_ptr(x, y);
			//real depth(1 - MIN(abs(result.distance) / maxDepth, 1.0));
			//p[0] = depth * 255;
			//p[1] = depth * 255;
			//p[2] = depth * 255;
			//p[0] = (result.normal.x + 1) * 128;
			//p[1] = (result.normal.y + 1) * 128;
			//p[2] = (result.normal.z + 1) * 128;
			p[0] = MAX(0, MIN(1, color.r)) * 255;
			p[1] = MAX(0, MIN(1, color.g)) * 255;
			p[2] = MAX(0, MIN(1, color.b)) * 255;
		}
	}
}

void quit(void)
{
#ifdef USE_GTK
	gtk_exit(0);
#endif
	exit(0);
}


int main(int argc, char *argv[])
{
	const int WIDTH = 400, HEIGHT = 400;
#ifdef USE_GTK
	const char IMAGE_FILE[] = "../resource/black.png";
	gtk_init(&argc, &argv);

	GtkWidget *window = gtk_window_new(GTK_WINDOW_TOPLEVEL);

	gtk_window_set_title(GTK_WINDOW(window), "fwjscience");
	gtk_window_set_default_size(GTK_WINDOW(window), WIDTH, HEIGHT);
	gtk_container_border_width(GTK_CONTAINER(window), 3);

	GtkWidget *image = gtk_image_new_from_file(IMAGE_FILE);
	GdkPixbuf *pixbuf = gtk_image_get_pixbuf(GTK_IMAGE(image));

	pixels_info pixinfo(pixbuf);
#else
	pixels_info pixinfo(WIDTH, HEIGHT);
#endif

	Geometry *scene_list[] = {
		/*new Cube(Vector3(0, 0, -24),
				Vector3(1, 0, 0.5).normalized(), Vector3(0, 1, 0).normalized(), Vector3(-0.5, 0, 1).normalized(),
				12, 12, 12, Checker(0, 0.5)),*/
		/*new Sphere(Vector3(8, -7, -16), 5, Blackbody(Color3(2.0, 1.3, 0.7))),
		new Sphere(Vector3(0, 0, -24), 12, Plastic(Color3(0.4, 0.7, 0.8), 0.2)),
		new Sphere(Vector3(-8, -7, -16), 5, Plastic(Color3(0.6, 0.8, 0.5), 0.98)),*/
		new RectPlane(Vector3(0, -12, -24), Vector3(0, 1, 0), Vector3(1, 0, 0), Vector3(0, 0, 1),
				20, 20, Checker(0.5, 0.1)),
		/*new Plane(Vector3(0, 1, 0), -12, Checker(0.5, 0.1)),*/
	};
	Scene scene(scene_list, sizeof(scene_list) / sizeof(Geometry *));

	Light *light_list[] = {
		new DirectedLight(Color3(1, 1, 1), Vector3(-1.75, -2, -2.5).normalized()),
		//new DirectedLight(Color3(0.3, 0.3, 0.0), Vector3(1.6, 8, -1).normalized()),
	};
	Lights lights(light_list, sizeof(light_list) / sizeof(Light *));

	/*Lights lights;
	//lights.add(new DirectedLight(Color3(0.7, 0.7, 1.0), Vector3(-1.75, -2, -2.5).normalized()));
	{
		ifstream fin("light.txt");
		if (!fin)
			throw 1;
		Color3 color;
		fin >> color.r >> color.g >> color.b;
		Vector3 vector;
		fin >> vector.x >> vector.y >> vector.z;
		lights.add(new DirectedLight(color, vector.normalized()));
		fin.close();
	}*/

	/*Scene scene;
	//lights.add(new DirectedLight(Color3(0.7, 0.7, 1.0), Vector3(-1.75, -2, -2.5).normalized()));
	{
		ifstream fin("scene.txt");
		if (!fin)
			throw 1;
		while (!fin.eof()) {
			Geometry *obj;
			int type;
			fin >> type;
			cout << type << endl;
			if (type == 1) {
				Vector3 center;
				{fin >> center.x >> center.y >> center.z;}
				real radius;
				fin >> radius;
				Color3 color;
				{fin >> color.r >> color.g >> color.b;}
				real reflectiveness;
				fin >> reflectiveness;
				obj = new Sphere(center, radius, Plastic(color, reflectiveness));
			} else if (type == 2) {
				Vector3 normal;
				{fin >> normal.x >> normal.y >> normal.z;}
				real distant;
				fin >> distant;
				real reflectiveness;
				fin >> reflectiveness;
				real scale;
				fin >> scale;
				obj = new Plane(normal, distant, Checker(reflectiveness, scale));
			}
			scene.add(obj);
		}
		fin.close();
	}*/

	render(pixinfo, scene, lights);

#ifdef USE_GTK
	gtk_container_add(GTK_CONTAINER(window), image);

	gtk_signal_connect(GTK_OBJECT(window), "delete_event",
			GTK_SIGNAL_FUNC(quit), NULL);

	gtk_widget_show_all(window);
	gtk_main();
#endif

#ifdef SAVE_IMG
	ofstream fout(SAVE_IMG);
	pixinfo.save_ppm(fout);
	fout.close();
#endif

	/*for (int i = 0; i < sizeof(scene_list) / sizeof(scene_list[0]); i++)
		delete scene_list[i];*/

	/*for (int i = 0; i < sizeof(light_list) / sizeof(light_list[0]); i++)
		delete light_list[i];*/

	return 0;
}

